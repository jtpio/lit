{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application/node_modules/@jupyterlab/shared-models/lib/ymodels.js"],"names":["deepCopy","o","JSON","parse","stringify","YFile","this","isDisposed","ydoc","source","getText","undoManager","trackedOrigins","Set","awareness","_changed","Signal","f","undoable","transact","destroy","undoStack","length","redoStack","undo","redo","clear","super","_modelObserver","event","changes","sourceChange","delta","emit","ysource","observe","toString","value","ytext","delete","insert","start","end","createStandaloneCell","cellType","id","YMarkdownCell","createStandalone","YCodeCell","YRawCell","YBaseCell","ymodel","_notebook","isStandalone","events","sourceEvent","find","target","get","outputEvent","outputsChange","modelEvent","keysChanged","has","change","keys","metadataChange","oldValue","undefined","newValue","getMetadata","executionCountChange","_prevSourceLength","_undoManager","observeDeep","_a","notebook","doc","UUID","set","prototype","cell_type","cell","create","getArray","getSource","getId","Self","constructor","unobserveDeep","Error","metadata","count","toArray","outputs","youtputs","fin","clone","getOutputs","execution_count","attachments","getAttachments"],"mappings":"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","file":"3599.26fcdb05f6ac3fe04295.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Signal } from '@lumino/signaling';\nimport { UUID } from '@lumino/coreutils';\nimport * as Y from 'yjs';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { Awareness } from 'y-protocols/awareness';\nconst deepCopy = (o) => JSON.parse(JSON.stringify(o));\nexport class YDocument {\n    constructor() {\n        this.isDisposed = false;\n        this.ydoc = new Y.Doc();\n        this.source = this.ydoc.getText('source');\n        this.undoManager = new Y.UndoManager([this.source], {\n            trackedOrigins: new Set([this])\n        });\n        this.awareness = new Awareness(this.ydoc);\n        this._changed = new Signal(this);\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.ydoc.transact(f, undoable ? this : null);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.isDisposed = true;\n        this.ydoc.destroy();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.undoManager.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.undoManager.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        this.undoManager.clear();\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n}\nexport class YFile extends YDocument {\n    constructor() {\n        super();\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (event) => {\n            const changes = {};\n            changes.sourceChange = event.changes.delta;\n            this._changed.emit(changes);\n        };\n        this.ysource = this.ydoc.getText('source');\n        this.ysource.observe(this._modelObserver);\n    }\n    static create() {\n        return new YFile();\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        this.transact(() => {\n            const ytext = this.ysource;\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n}\n/**\n * Shared implementation of the Shared Document types.\n *\n * Shared cells can be inserted into a SharedNotebook.\n * Shared cells only start emitting events when they are connected to a SharedNotebook.\n *\n * \"Standalone\" cells must not be inserted into a (Shared)Notebook.\n * Standalone cells emit events immediately after they have been created, but they must not\n * be included into a (Shared)Notebook.\n */\nexport class YNotebook extends YDocument {\n    constructor() {\n        super();\n        /**\n         * Handle a change to the list of cells.\n         */\n        this._onYCellsChanged = (event) => {\n            // update the typeâ‡”cell mapping by iterating through the addded/removed types\n            event.changes.added.forEach(item => {\n                const type = item.content.type;\n                if (!this._ycellMapping.has(type)) {\n                    this._ycellMapping.set(type, createCellFromType(type));\n                }\n                const cell = this._ycellMapping.get(type);\n                cell._notebook = this;\n                cell._undoManager = this.undoManager;\n            });\n            event.changes.deleted.forEach(item => {\n                const type = item.content.type;\n                const model = this._ycellMapping.get(type);\n                if (model) {\n                    model.dispose();\n                    this._ycellMapping.delete(type);\n                }\n            });\n            let index = 0;\n            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells\n            const cellsChange = [];\n            event.changes.delta.forEach((d) => {\n                if (d.insert != null) {\n                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));\n                    cellsChange.push({ insert: insertedCells });\n                    this.cells.splice(index, 0, ...insertedCells);\n                    index += d.insert.length;\n                }\n                else if (d.delete != null) {\n                    cellsChange.push(d);\n                    this.cells.splice(index, d.delete);\n                }\n                else if (d.retain != null) {\n                    cellsChange.push(d);\n                    index += d.retain;\n                }\n            });\n            this._changed.emit({\n                cellsChange: cellsChange\n            });\n        };\n        this.ycells = this.ydoc.getArray('cells');\n        this.ymeta = this.ydoc.getMap('meta');\n        this.ymodel = this.ydoc.getMap('model');\n        this.undoManager = new Y.UndoManager([this.ycells], {\n            trackedOrigins: new Set([this])\n        });\n        this._ycellMapping = new Map();\n        this.nbformat_minor = nbformat.MINOR_VERSION;\n        this.nbformat = nbformat.MAJOR_VERSION;\n        this.ycells.observe(this._onYCellsChanged);\n        this.cells = this.ycells.toArray().map(ycell => {\n            if (!this._ycellMapping.has(ycell)) {\n                this._ycellMapping.set(ycell, createCellFromType(ycell));\n            }\n            return this._ycellMapping.get(ycell);\n        });\n    }\n    /**\n     * Get a shared cell by index.\n     *\n     * @param index: Cell's position.\n     *\n     * @returns The requested shared cell.\n     */\n    getCell(index) {\n        return this.cells[index];\n    }\n    /**\n     * Insert a shared cell into a specific position.\n     *\n     * @param index: Cell's position.\n     *\n     * @param cell: Cell to insert.\n     */\n    insertCell(index, cell) {\n        this.insertCells(index, [cell]);\n    }\n    /**\n     * Insert a list of shared cells into a specific position.\n     *\n     * @param index: Position to insert the cells.\n     *\n     * @param cells: Array of shared cells to insert.\n     */\n    insertCells(index, cells) {\n        cells.forEach(cell => {\n            this._ycellMapping.set(cell.ymodel, cell);\n            // cell.yawareness = this.yawareness;\n            // cell.yUndoManager = this.yUndoManager;\n        });\n        this.transact(() => {\n            this.ycells.insert(index, cells.map(cell => cell.ymodel));\n        });\n    }\n    /**\n     * Move a cell.\n     *\n     * @param fromIndex: Index of the cell to move.\n     *\n     * @param toIndex: New position of the cell.\n     */\n    moveCell(fromIndex, toIndex) {\n        this.transact(() => {\n            const fromCell = this.getCell(fromIndex).clone();\n            this.deleteCell(fromIndex);\n            this.insertCell(toIndex, fromCell);\n        });\n    }\n    /**\n     * Remove a cell.\n     *\n     * @param index: Index of the cell to remove.\n     */\n    deleteCell(index) {\n        this.deleteCellRange(index, index + 1);\n    }\n    /**\n     * Remove a range of cells.\n     *\n     * @param from: The start index of the range to remove (inclusive).\n     *\n     * @param to: The end index of the range to remove (exclusive).\n     */\n    deleteCellRange(from, to) {\n        this.transact(() => {\n            this.ycells.delete(from, to - from);\n        });\n    }\n    /**\n     * Returns the metadata associated with the notebook.\n     *\n     * @returns Notebook's metadata.\n     */\n    getMetadata() {\n        const meta = this.ymeta.get('metadata');\n        return meta ? deepCopy(meta) : { orig_nbformat: 1 };\n    }\n    /**\n     * Sets the metadata associated with the notebook.\n     *\n     * @param metadata: Notebook's metadata.\n     */\n    setMetadata(value) {\n        this.ymeta.set('metadata', deepCopy(value));\n    }\n    /**\n     * Updates the metadata associated with the notebook.\n     *\n     * @param value: Metadata's attribute to update.\n     */\n    updateMetadata(value) {\n        this.ymeta.set('metadata', Object.assign({}, this.getMetadata(), value));\n    }\n    /**\n     * Create a new YNotebook.\n     */\n    static create() {\n        return new YNotebook();\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.ycells.unobserve(this._onYCellsChanged);\n    }\n}\n/**\n * Create a new shared cell given the type.\n */\nexport const createCellFromType = (type) => {\n    switch (type.get('cell_type')) {\n        case 'code':\n            return new YCodeCell(type);\n        case 'markdown':\n            return new YMarkdownCell(type);\n        case 'raw':\n            return new YRawCell(type);\n        default:\n            throw new Error('Found unknown cell type');\n    }\n};\n/**\n * Create a new standalone cell given the type.\n */\nexport const createStandaloneCell = (cellType, id) => {\n    switch (cellType) {\n        case 'markdown':\n            return YMarkdownCell.createStandalone(id);\n        case 'code':\n            return YCodeCell.createStandalone(id);\n        default:\n            // raw\n            return YRawCell.createStandalone(id);\n    }\n};\nexport class YBaseCell {\n    constructor(ymodel) {\n        /**\n         * The notebook that this cell belongs to.\n         */\n        this._notebook = null;\n        /**\n         * Whether the cell is standalone or not.\n         *\n         * If the cell is standalone. It cannot be\n         * inserted into a YNotebook because the Yjs model is already\n         * attached to an anonymous Y.Doc instance.\n         */\n        this.isStandalone = false;\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (events) => {\n            const changes = {};\n            const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));\n            if (sourceEvent) {\n                changes.sourceChange = sourceEvent.changes.delta;\n            }\n            const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));\n            if (outputEvent) {\n                changes.outputsChange = outputEvent.changes.delta;\n            }\n            const modelEvent = events.find(event => event.target === this.ymodel);\n            if (modelEvent && modelEvent.keysChanged.has('metadata')) {\n                const change = modelEvent.changes.keys.get('metadata');\n                changes.metadataChange = {\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.getMetadata()\n                };\n            }\n            if (modelEvent && modelEvent.keysChanged.has('execution_count')) {\n                const change = modelEvent.changes.keys.get('execution_count');\n                changes.executionCountChange = {\n                    oldValue: change.oldValue,\n                    newValue: this.ymodel.get('execution_count')\n                };\n            }\n            // The model allows us to replace the complete source with a new string. We express this in the Delta format\n            // as a replace of the complete string.\n            const ysource = this.ymodel.get('source');\n            if (modelEvent && modelEvent.keysChanged.has('source')) {\n                changes.sourceChange = [\n                    { delete: this._prevSourceLength },\n                    { insert: ysource.toString() }\n                ];\n            }\n            this._prevSourceLength = ysource.length;\n            this._changed.emit(changes);\n        };\n        this.isDisposed = false;\n        this._undoManager = null;\n        this._changed = new Signal(this);\n        this.ymodel = ymodel;\n        const ysource = ymodel.get('source');\n        this._prevSourceLength = ysource ? ysource.length : 0;\n        this.ymodel.observeDeep(this._modelObserver);\n    }\n    get ysource() {\n        return this.ymodel.get('source');\n    }\n    get awareness() {\n        var _a;\n        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.awareness) || null;\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.notebook && undoable\n            ? this.notebook.transact(f)\n            : this.ymodel.doc.transact(f, this);\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get undoManager() {\n        return this.notebook ? this.notebook.undoManager : this._undoManager;\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return !!this.undoManager && this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return !!this.undoManager && this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get notebook() {\n        return this._notebook;\n    }\n    /**\n     * Create a new YRawCell that can be inserted into a YNotebook\n     */\n    static create(id = UUID.uuid4()) {\n        const ymodel = new Y.Map();\n        const ysource = new Y.Text();\n        ymodel.set('source', ysource);\n        ymodel.set('metadata', {});\n        ymodel.set('cell_type', this.prototype.cell_type);\n        ymodel.set('id', id);\n        return new this(ymodel);\n    }\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        const cell = this.create(id);\n        cell.isStandalone = true;\n        new Y.Doc().getArray().insert(0, [cell.ymodel]);\n        cell._undoManager = new Y.UndoManager([cell.ymodel], {\n            trackedOrigins: new Set([cell])\n        });\n        return cell;\n    }\n    /**\n     * Clone the cell.\n     *\n     * @todo clone should only be available in the specific implementations i.e. ISharedCodeCell\n     */\n    clone() {\n        const ymodel = new Y.Map();\n        const ysource = new Y.Text(this.getSource());\n        ymodel.set('source', ysource);\n        ymodel.set('metadata', this.getMetadata());\n        ymodel.set('cell_type', this.cell_type);\n        ymodel.set('id', this.getId());\n        const Self = this.constructor;\n        return new Self(ymodel);\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.ymodel.unobserveDeep(this._modelObserver);\n    }\n    /**\n     * Gets the cell attachments.\n     *\n     * @returns The cell attachments.\n     */\n    getAttachments() {\n        return this.ymodel.get('attachments');\n    }\n    /**\n     * Sets the cell attachments\n     *\n     * @param attchments: The cell attachments.\n     */\n    setAttachments(value) {\n        this.transact(() => {\n            if (value == null) {\n                this.ymodel.set('attachments', value);\n            }\n            else {\n                this.ymodel.delete('attachments');\n            }\n        });\n    }\n    /**\n     * Get cell id.\n     *\n     * @returns Cell id\n     */\n    getId() {\n        return this.ymodel.get('id');\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ymodel.get('source').toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        const ytext = this.ymodel.get('source');\n        this.transact(() => {\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.\n        // this.ymodel.set('source', new Y.Text(value));\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        throw new Error('A YBaseCell must not be constructed');\n    }\n    /**\n     * Returns the metadata associated with the notebook.\n     *\n     * @returns Notebook's metadata.\n     */\n    getMetadata() {\n        return deepCopy(this.ymodel.get('metadata'));\n    }\n    /**\n     * Sets the metadata associated with the notebook.\n     *\n     * @param metadata: Notebook's metadata.\n     */\n    setMetadata(value) {\n        this.transact(() => {\n            this.ymodel.set('metadata', deepCopy(value));\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: this.cell_type,\n            source: this.getSource(),\n            metadata: this.getMetadata()\n        };\n    }\n}\nexport class YCodeCell extends YBaseCell {\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        return 'code';\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    get execution_count() {\n        return this.ymodel.get('execution_count');\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    set execution_count(count) {\n        this.transact(() => {\n            this.ymodel.set('execution_count', count);\n        });\n    }\n    /**\n     * Execution, display, or stream outputs.\n     */\n    getOutputs() {\n        return deepCopy(this.ymodel.get('outputs').toArray());\n    }\n    /**\n     * Replace all outputs.\n     */\n    setOutputs(outputs) {\n        const youtputs = this.ymodel.get('outputs');\n        this.transact(() => {\n            youtputs.delete(0, youtputs.length);\n            youtputs.insert(0, outputs);\n        });\n    }\n    /**\n     * Replace content from `start' to `end` with `outputs`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param outputs: New outputs (optional).\n     */\n    updateOutputs(start, end, outputs = []) {\n        const youtputs = this.ymodel.get('outputs');\n        const fin = end < youtputs.length ? end - start : youtputs.length - start;\n        this.transact(() => {\n            youtputs.delete(start, fin);\n            youtputs.insert(start, outputs);\n        });\n    }\n    /**\n     * Create a new YCodeCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        const cell = super.create(id);\n        cell.ymodel.set('execution_count', 0); // for some default value\n        cell.ymodel.set('outputs', new Y.Array());\n        return cell;\n    }\n    /**\n     * Create a new YCodeCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        const cell = super.createStandalone(id);\n        cell.ymodel.set('execution_count', null); // for some default value\n        cell.ymodel.set('outputs', new Y.Array());\n        return cell;\n    }\n    /**\n     * Create a new YCodeCell that can be inserted into a YNotebook\n     *\n     * @todo clone should only be available in the specific implementations i.e. ISharedCodeCell\n     */\n    clone() {\n        const cell = super.clone();\n        const youtputs = new Y.Array();\n        youtputs.insert(0, this.getOutputs());\n        cell.ymodel.set('execution_count', this.execution_count); // for some default value\n        cell.ymodel.set('outputs', youtputs);\n        return cell;\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'code',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            outputs: this.getOutputs(),\n            execution_count: this.execution_count\n        };\n    }\n}\nexport class YRawCell extends YBaseCell {\n    /**\n     * Create a new YRawCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'raw';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'raw',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\nexport class YMarkdownCell extends YBaseCell {\n    /**\n     * Create a new YMarkdownCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * Create a new YMarkdownCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'markdown';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'markdown',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\nexport default YNotebook;\n//# sourceMappingURL=ymodels.js.map"],"sourceRoot":""}