{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/array.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/binary.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/buffer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/decoding.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/number.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/encoding.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/error.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/function.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/iterator.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/symbol.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/pair.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/dom.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/logging.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/math.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/object.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/observable.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/isomorphic.js/browser.mjs","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/random.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/set.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/time.js"],"names":["last","arr","length","appendTo","dest","src","i","push","from","Array","equalFlat","a","b","f","item","index","every","BIT1","BIT2","BIT3","BIT4","BIT6","BIT7","BIT8","BITS5","BITS6","BITS7","BITS8","BITS31","createUint8ArrayFromLen","len","Uint8Array","createUint8ArrayViewFromArrayBuffer","buffer","byteOffset","createUint8ArrayFromArrayBuffer","toBase64","bytes","s","byteLength","btoa","Buffer","toString","fromBase64","atob","charCodeAt","buf","copyUint8Array","uint8Array","newBuf","set","Decoder","this","pos","createDecoder","readUint8Array","decoder","view","readVarUint8Array","readVarUint","readTailAsUint8Array","readUint8","readUint32","uint","num","r","Error","readVarInt","sign","readVarString","remainingLen","encodedString","String","fromCodePoint","nextLen","subarray","apply","decodeURIComponent","escape","readFromDataView","dv","DataView","readAnyLookupTable","getFloat32","getFloat64","getBigInt64","obj","readAny","RleDecoder","reader","super","count","UintOptRleDecoder","isNegative","IntDiffOptRleDecoder","diff","hasCount","StringDecoder","str","spos","end","read","res","slice","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isInteger","isFinite","math","isNaN","Encoder","cpos","cbuf","bufs","createEncoder","encoder","toUint8Array","uint8arr","curPos","d","write","bufferLen","writeUint8","writeUint32","writeVarUint","writeVarInt","writeVarString","unescape","encodeURIComponent","codePointAt","writeUint8Array","leftCopyLen","rightCopyLen","writeVarUint8Array","writeOnDataView","verifyLen","dview","floatTestBed","ArrayBuffer","writeAny","data","setFloat32","writeFloat32","setFloat64","writeFloat64","setBigInt64","writeBigInt64","keys","Object","key","RleEncoder","writer","w","v","flushUintOptRleEncoder","UintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","string","join","create","methodUnimplemented","unexpectedCase","callAll","fs","args","nop","equalityFlat","constructor","equalityDeep","equalityStrict","Set","size","value","has","Map","get","createIterator","next","Symbol","iterator","iteratorFilter","filter","done","iteratorMap","fmap","undefined","Pair","left","right","doc","document","DOMParser","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","BOLD","UNBOLD","BLUE","GREY","GREEN","RED","PURPLE","ORANGE","UNCOLOR","_browserStyleMap","_nodeStyleMap","computeLoggingArgs","strBuilder","logArgs","arg","style","styles","currentStyle","m","unshift","print","console","log","vconsoles","forEach","vc","loggingColors","nextColor","lastLoggingTime","time","createModuleLogger","moduleName","color","debugRegexVar","doLogging","RegExp","test","timeNow","timeDiff","map","JSON","stringify","floor","Math","abs","ceil","log10","imul","round","add","log2","sqrt","min","max","isNegativeZero","pow","n","assign","results","hasProperty","prototype","hasOwnProperty","call","val","Observable","_observers","name","_f","off","on","observers","delete","values","window","performance","isoCrypto","crypto","cryptoRandomBuffer","getRandomValues","random","rand","uint32","Uint32Array","uuidv4Template","uuidv4","replace","c","getUnixTime","Date","now"],"mappings":"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","file":"8398.2de1ada7e0a75a6ebc17.js","sourcesContent":["/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n","/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data => {\n  const encoder = encoding.createEncoder()\n  encoding.writeAny(encoder, data)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let len = 6\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nexport const readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nexport const HIGHEST_INT32 = binary.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num >>>= 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n","/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nexport const mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nexport const createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nexport const iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nexport const iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n","/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nexport const create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nexport const isSymbol = s => typeof s === 'symbol'\n","/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nexport class Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nexport const create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nexport const createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nexport const forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nexport const map = (arr, f) => arr.map(p => f(p.left, p.right))\n","/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\nimport * as pair from './pair.js'\nimport * as map from './map.js'\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nexport const doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nexport const domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nexport const emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nexport const remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nexport const canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nexport const pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nexport const pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nexport const mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nexport const querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nexport const querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nexport const replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const appendChild = (parent, child) => parent.appendChild(child)\n\nexport const ELEMENT_NODE = doc.ELEMENT_NODE\nexport const TEXT_NODE = doc.TEXT_NODE\nexport const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nexport const COMMENT_NODE = doc.COMMENT_NODE\nexport const DOCUMENT_NODE = doc.DOCUMENT_NODE\nexport const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nexport const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nexport const checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nexport const isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n","/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\nimport * as env from './environment.js'\nimport * as symbol from './symbol.js'\nimport * as pair from './pair.js'\nimport * as dom from './dom.js'\nimport * as json from './json.js'\nimport * as map from './map.js'\nimport * as eventloop from './eventloop.js'\nimport * as math from './math.js'\nimport * as time from './time.js'\nimport * as func from './function.js'\n\nexport const BOLD = symbol.create()\nexport const UNBOLD = symbol.create()\nexport const BLUE = symbol.create()\nexport const GREY = symbol.create()\nexport const GREEN = symbol.create()\nexport const RED = symbol.create()\nexport const PURPLE = symbol.create()\nexport const ORANGE = symbol.create()\nexport const UNCOLOR = symbol.create()\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: pair.create('font-weight', 'bold'),\n  [UNBOLD]: pair.create('font-weight', 'normal'),\n  [BLUE]: pair.create('color', 'blue'),\n  [GREEN]: pair.create('color', 'green'),\n  [GREY]: pair.create('color', 'grey'),\n  [RED]: pair.create('color', 'red'),\n  [PURPLE]: pair.create('color', 'purple'),\n  [ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: pair.create('color', 'black')\n}\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = map.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = dom.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _nodeStyleMap[arg]\n    if (style !== undefined) {\n      strBuilder.push(style)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg)\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m')\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/* istanbul ignore next */\nconst computeLoggingArgs = env.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(ORANGE)\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nexport const printError = err => {\n  console.error(err)\n  vconsoles.forEach(vc => vc.printError(err))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nexport const printImg = (url, height) => {\n  if (env.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`)\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nexport const printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args))\n}\n\nexport const groupEnd = () => {\n  console.groupEnd()\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd())\n}\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nexport const printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()))\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nexport const printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height)\n\nexport const vconsoles = new Set()\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = dom.element('span', [pair.create('style', dom.mapToStyleString(currentStyle))], [dom.text(arg)])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + json.stringify(content) + ' '\n      }\n      spans.push(dom.element('span', [], [dom.text(/** @type {string} */ (content))]))\n    }\n  }\n  return spans\n}\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* istanbul ignore next */\nexport class VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    eventloop.enqueue(() => {\n      const triangleDown = dom.element('span', [pair.create('hidden', collapsed), pair.create('style', 'color:grey;font-size:120%;')], [dom.text('')])\n      const triangleRight = dom.element('span', [pair.create('hidden', !collapsed), pair.create('style', 'color:grey;font-size:125%;')], [dom.text('')])\n      const content = dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, dom.text(' ')].concat(_computeLineSpans(args)))\n      const nextContainer = dom.element('div', [pair.create('hidden', collapsed)])\n      const nextLine = dom.element('div', [], [content, nextContainer])\n      dom.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      dom.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    eventloop.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('img', [pair.create('src', url), pair.create('height', `${math.round(height * 1.5)}px`)])])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    eventloop.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nexport const createVConsole = dom => new VConsole(dom)\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = time.getUnixTime()\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nexport const createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = env.getVariable('log')\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n\n  return !doLogging ? func.nop : (...args) => {\n    const timeNow = time.getUnixTime()\n    const timeDiff = timeNow - lastLoggingTime\n    lastLoggingTime = timeNow\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms')\n  }\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n","/* eslint-env browser */\nexport const performance = typeof window === 'undefined' ? null : (typeof window.performance !== 'undefined' && window.performance) || null\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nexport const cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n","\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\nimport * as math from './math.js'\nimport { cryptoRandomBuffer } from './isomorphic.js'\n\nexport const rand = Math.random\n\n/* istanbul ignore next */\nexport const uint32 = () => new Uint32Array(cryptoRandomBuffer(4))[0]\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nexport const oneOf = arr => arr[math.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nexport const uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n"],"sourceRoot":""}